{"version":3,"file":"index.js","sources":["../../../node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../../../node_modules/@babel/runtime/helpers/iterableToArray.js","../../../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","../../../node_modules/@babel/runtime/helpers/nonIterableSpread.js","../../../node_modules/@babel/runtime/helpers/toConsumableArray.js","../../../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../../../node_modules/@babel/runtime/helpers/nonIterableRest.js","../../../node_modules/@babel/runtime/helpers/slicedToArray.js","../../../node_modules/@babel/runtime/helpers/defineProperty.js","../src/utils/weak-maps.ts","../src/create-editor.ts","../../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","../../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js","../src/utils/string.ts","../src/interfaces/element.ts","../src/interfaces/editor.ts","../src/interfaces/location.ts","../src/interfaces/node.ts","../src/interfaces/operation.ts","../src/interfaces/path.ts","../src/interfaces/path-ref.ts","../src/interfaces/point.ts","../src/interfaces/point-ref.ts","../src/interfaces/range.ts","../src/interfaces/range-ref.ts","../src/interfaces/text.ts","../src/transforms/general.ts","../src/transforms/node.ts","../src/transforms/selection.ts","../src/transforms/text.ts","../src/transforms/index.ts"],"sourcesContent":["function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","var arrayWithoutHoles = require(\"./arrayWithoutHoles.js\");\n\nvar iterableToArray = require(\"./iterableToArray.js\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread.js\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","var arrayWithHoles = require(\"./arrayWithHoles.js\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\n\nvar nonIterableRest = require(\"./nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","import { Editor, Path, PathRef, PointRef, RangeRef } from '..'\n\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\n","import {\n  Descendant,\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  PointRef,\n  Range,\n  RangeRef,\n  Text,\n  Transforms,\n} from './'\nimport { DIRTY_PATHS, FLUSHING } from './utils/weak-maps'\n\n/**\n * Create a new Slate `Editor` object.\n */\n\nexport const createEditor = (): Editor => {\n  const editor: Editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n\n    apply: (op: Operation) => {\n      for (const ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.pointRefs(editor)) {\n        PointRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.rangeRefs(editor)) {\n        RangeRef.transform(ref, op)\n      }\n\n      const set = new Set()\n      const dirtyPaths: Path[] = []\n\n      const add = (path: Path | null) => {\n        if (path) {\n          const key = path.join(',')\n\n          if (!set.has(key)) {\n            set.add(key)\n            dirtyPaths.push(path)\n          }\n        }\n      }\n\n      const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\n      const newDirtyPaths = getDirtyPaths(op)\n\n      for (const path of oldDirtyPaths) {\n        const newPath = Path.transform(path, op)\n        add(newPath)\n      }\n\n      for (const path of newDirtyPaths) {\n        add(path)\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths)\n      Transforms.transform(editor, op)\n      editor.operations.push(op)\n      Editor.normalize(editor)\n\n      // Clear any formats applied to the cursor if the selection changes.\n      if (op.type === 'set_selection') {\n        editor.marks = null\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true)\n\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false)\n          editor.onChange()\n          editor.operations = []\n        })\n      }\n    },\n\n    addMark: (key: string, value: any) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(\n            editor,\n            { [key]: value },\n            { match: Text.isText, split: true }\n          )\n        } else {\n          const marks = {\n            ...(Editor.marks(editor) || {}),\n            [key]: value,\n          }\n\n          editor.marks = marks\n          if (!FLUSHING.get(editor)) {\n            editor.onChange()\n          }\n        }\n      }\n    },\n\n    deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit, reverse: true })\n      }\n    },\n\n    deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit })\n      }\n    },\n\n    deleteFragment: (direction?: 'forward' | 'backward') => {\n      const { selection } = editor\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, { reverse: direction === 'backward' })\n      }\n    },\n\n    getFragment: () => {\n      const { selection } = editor\n\n      if (selection) {\n        return Node.fragment(editor, selection)\n      }\n      return []\n    },\n\n    insertBreak: () => {\n      Transforms.splitNodes(editor, { always: true })\n    },\n\n    insertFragment: (fragment: Node[]) => {\n      Transforms.insertFragment(editor, fragment)\n    },\n\n    insertNode: (node: Node) => {\n      Transforms.insertNodes(editor, node)\n    },\n\n    insertText: (text: string) => {\n      const { selection, marks } = editor\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          const inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest',\n          })\n\n          if (inline) {\n            const [, inlinePath] = inline\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              const point = Editor.after(editor, inlinePath)!\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point,\n              })\n            }\n          }\n        }\n\n        if (marks) {\n          const node = { text, ...marks }\n          Transforms.insertNodes(editor, node)\n        } else {\n          Transforms.insertText(editor, text)\n        }\n\n        editor.marks = null\n      }\n    },\n\n    normalizeNode: (entry: NodeEntry) => {\n      const [node, path] = entry\n\n      // There are no core normalizations for text nodes.\n      if (Text.isText(node)) {\n        return\n      }\n\n      // Ensure that block and inline nodes have at least one text child.\n      if (Element.isElement(node) && node.children.length === 0) {\n        const child = { text: '' }\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true,\n        })\n        return\n      }\n\n      // Determine whether the node should have block or inline children.\n      const shouldHaveInlines = Editor.isEditor(node)\n        ? false\n        : Element.isElement(node) &&\n          (editor.isInline(node) ||\n            node.children.length === 0 ||\n            Text.isText(node.children[0]) ||\n            editor.isInline(node.children[0]))\n\n      // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n      let n = 0\n\n      for (let i = 0; i < node.children.length; i++, n++) {\n        const currentNode = Node.get(editor, path)\n        if (Text.isText(currentNode)) continue\n        const child = node.children[i] as Descendant\n        const prev = currentNode.children[n - 1] as Descendant\n        const isLast = i === node.children.length - 1\n        const isInlineOrText =\n          Text.isText(child) ||\n          (Element.isElement(child) && editor.isInline(child))\n\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, { at: path.concat(n), voids: true })\n          n--\n        } else if (Element.isElement(child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(child)) {\n            if (prev == null || !Text.isText(prev)) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n++\n            } else if (isLast) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n + 1),\n                voids: true,\n              })\n              n++\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(child, prev, { loose: true })) {\n              Transforms.mergeNodes(editor, { at: path.concat(n), voids: true })\n              n--\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true,\n              })\n              n--\n            } else if (isLast && child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n--\n            }\n          }\n        }\n      }\n    },\n\n    removeMark: (key: string) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true,\n          })\n        } else {\n          const marks = { ...(Editor.marks(editor) || {}) }\n          delete marks[key]\n          editor.marks = marks\n          if (!FLUSHING.get(editor)) {\n            editor.onChange()\n          }\n        }\n      }\n    },\n  }\n\n  return editor\n}\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\n\nconst getDirtyPaths = (op: Operation): Path[] => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const p = Path.transform(ancestor, op)\n        oldAncestors.push(p!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const p = Path.transform(ancestor, op)\n        newAncestors.push(p!)\n      }\n\n      const newParent = newAncestors[newAncestors.length - 1]\n      const newIndex = newPath[newPath.length - 1]\n      const resultPath = newParent.concat(newIndex)\n\n      return [...oldAncestors, ...newAncestors, resultPath]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","/**\n * Constants for string distance checking.\n */\n\nconst SPACE = /\\s/\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\nconst ZERO_WIDTH_JOINER = 0x200d\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nexport const getCharacterDistance = (text: string): number => {\n  let offset = 0\n  // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n  let prev: 'SURR' | 'MOD' | 'ZWJ' | 'VAR' | 'BMP' | null = null\n  let charCode = text.charCodeAt(0)\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      const modifier = isModifier(charCode, text, offset)\n\n      // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n      if (prev === 'SURR' || prev === 'BMP') {\n        break\n      }\n\n      offset += 2\n      prev = modifier ? 'MOD' : 'SURR'\n      charCode = text.charCodeAt(offset)\n      // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n      continue\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1\n      prev = 'ZWJ'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break\n      }\n      offset += 1\n      prev = 'BMP'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break\n      }\n      offset += 1\n      prev = 'VAR'\n      charCode = text.charCodeAt(offset)\n      continue\n    }\n\n    // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n    if (prev === 'MOD') {\n      offset += 1\n      break\n    }\n\n    // If while loop ever gets here, we're done (e.g latin chars).\n    break\n  }\n\n  return offset || 1\n}\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nexport const getWordDistance = (text: string): number => {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharacterDistance(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWordCharacter(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nconst isWordCharacter = (char: string, remaining: string): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharacterDistance(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n\n    if (isWordCharacter(next, rest)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Determines if `code` is a surrogate\n */\n\nconst isSurrogate = (code: number): boolean =>\n  SURROGATE_START <= code && code <= SURROGATE_END\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n */\n\nconst isModifier = (code: number, text: string, offset: number): boolean => {\n  if (code === 0xd83c) {\n    const next = text.charCodeAt(offset + 1)\n    return next <= 0xdfff && next >= 0xdffb\n  }\n  return false\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n */\n\nconst isVariationSelector = (code: number): boolean => {\n  return code <= 0xfe0f && code >= 0xfe00\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n */\n\nconst isBMPEmoji = (code: number): boolean => {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return (\n    code === 0x2764 || // heart (❤)\n    code === 0x2642 || // male (♂)\n    code === 0x2640 || // female (♀)\n    code === 0x2620 || // scull (☠)\n    code === 0x2695 || // medical (⚕)\n    code === 0x2708 || // plane (✈️)\n    code === 0x25ef // large circle (◯)\n  )\n}\n","import isPlainObject from 'is-plain-object'\nimport { Editor, Node, Path, Descendant, ExtendedType, Ancestor } from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\n\nexport interface BaseElement {\n  children: Descendant[]\n}\n\nexport type Element = ExtendedType<'Element', BaseElement>\n\nexport interface ElementInterface {\n  isAncestor: (value: any) => value is Ancestor\n  isElement: (value: any) => value is Element\n  isElementList: (value: any) => value is Element[]\n  isElementProps: (props: any) => props is Partial<Element>\n  isElementType: <T extends Element>(\n    value: any,\n    elementVal: string,\n    elementKey?: string\n  ) => value is T\n  matches: (element: Element, props: Partial<Element>) => boolean\n}\n\n/**\n * Shared the function with isElementType utility\n */\nconst isElement = (value: any): value is Element => {\n  return (\n    isPlainObject(value) &&\n    Node.isNodeList(value.children) &&\n    !Editor.isEditor(value)\n  )\n}\n\nexport const Element: ElementInterface = {\n  /**\n   * Check if a value implements the 'Ancestor' interface.\n   */\n\n  isAncestor(value: any): value is Ancestor {\n    return isPlainObject(value) && Node.isNodeList(value.children)\n  },\n\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n\n  isElement,\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n\n  isElementList(value: any): value is Element[] {\n    return Array.isArray(value) && value.every(val => Element.isElement(val))\n  },\n\n  /**\n   * Check if a set of props is a partial of Element.\n   */\n\n  isElementProps(props: any): props is Partial<Element> {\n    return (props as Partial<Element>).children !== undefined\n  },\n\n  /**\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\n   * Default it check to `type` key value\n   */\n\n  isElementType: <T extends Element>(\n    value: any,\n    elementVal: string,\n    elementKey: string = 'type'\n  ): value is T => {\n    return isElement(value) && value[elementKey] === elementVal\n  },\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n\n  matches(element: Element, props: Partial<Element>): boolean {\n    for (const key in props) {\n      if (key === 'children') {\n        continue\n      }\n\n      if (element[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n\nexport type ElementEntry = [Element, Path]\n","import isPlainObject from 'is-plain-object'\nimport { reverse as reverseText } from 'esrever'\n\nimport {\n  Ancestor,\n  ExtendedType,\n  Location,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  Point,\n  PointRef,\n  Range,\n  RangeRef,\n  Span,\n  Text,\n  Transforms,\n} from '..'\nimport {\n  DIRTY_PATHS,\n  NORMALIZING,\n  PATH_REFS,\n  POINT_REFS,\n  RANGE_REFS,\n} from '../utils/weak-maps'\nimport { getWordDistance, getCharacterDistance } from '../utils/string'\nimport { Descendant } from './node'\nimport { Element } from './element'\n\nexport type BaseSelection = Range | null\n\nexport type Selection = ExtendedType<'Selection', BaseSelection>\n\n/**\n * The `Editor` interface stores all the state of a Slate editor. It is extended\n * by plugins that wish to add their own helpers and implement new behaviors.\n */\n\nexport interface BaseEditor {\n  children: Descendant[]\n  selection: Selection\n  operations: Operation[]\n  marks: Omit<Text, 'text'> | null\n\n  // Schema-specific node behaviors.\n  isInline: (element: Element) => boolean\n  isVoid: (element: Element) => boolean\n  normalizeNode: (entry: NodeEntry) => void\n  onChange: () => void\n\n  // Overrideable core actions.\n  addMark: (key: string, value: any) => void\n  apply: (operation: Operation) => void\n  deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteFragment: (direction?: 'forward' | 'backward') => void\n  getFragment: () => Descendant[]\n  insertBreak: () => void\n  insertFragment: (fragment: Node[]) => void\n  insertNode: (node: Node) => void\n  insertText: (text: string) => void\n  removeMark: (key: string) => void\n}\n\nexport type Editor = ExtendedType<'Editor', BaseEditor>\n\nexport interface EditorInterface {\n  above: <T extends Ancestor>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  addMark: (editor: Editor, key: string, value: any) => void\n  after: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    }\n  ) => Point | undefined\n  before: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    }\n  ) => Point | undefined\n  deleteBackward: (\n    editor: Editor,\n    options?: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    }\n  ) => void\n  deleteForward: (\n    editor: Editor,\n    options?: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    }\n  ) => void\n  deleteFragment: (\n    editor: Editor,\n    options?: {\n      direction?: 'forward' | 'backward'\n    }\n  ) => void\n  edges: (editor: Editor, at: Location) => [Point, Point]\n  end: (editor: Editor, at: Location) => Point\n  first: (editor: Editor, at: Location) => NodeEntry\n  fragment: (editor: Editor, at: Location) => Descendant[]\n  hasBlocks: (editor: Editor, element: Element) => boolean\n  hasInlines: (editor: Editor, element: Element) => boolean\n  hasPath: (editor: Editor, path: Path) => boolean\n  hasTexts: (editor: Editor, element: Element) => boolean\n  insertBreak: (editor: Editor) => void\n  insertFragment: (editor: Editor, fragment: Node[]) => void\n  insertNode: (editor: Editor, node: Node) => void\n  insertText: (editor: Editor, text: string) => void\n  isBlock: (editor: Editor, value: any) => value is Element\n  isEditor: (value: any) => value is Editor\n  isEnd: (editor: Editor, point: Point, at: Location) => boolean\n  isEdge: (editor: Editor, point: Point, at: Location) => boolean\n  isEmpty: (editor: Editor, element: Element) => boolean\n  isInline: (editor: Editor, value: any) => value is Element\n  isNormalizing: (editor: Editor) => boolean\n  isStart: (editor: Editor, point: Point, at: Location) => boolean\n  isVoid: (editor: Editor, value: any) => value is Element\n  last: (editor: Editor, at: Location) => NodeEntry\n  leaf: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry<Text>\n  levels: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<NodeEntry<T>, void, undefined>\n  marks: (editor: Editor) => Omit<Text, 'text'> | null\n  next: <T extends Descendant>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  node: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry\n  nodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<NodeEntry<T>, void, undefined>\n  normalize: (\n    editor: Editor,\n    options?: {\n      force?: boolean\n    }\n  ) => void\n  parent: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry<Ancestor>\n  path: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => Path\n  pathRef: (\n    editor: Editor,\n    path: Path,\n    options?: {\n      affinity?: 'backward' | 'forward' | null\n    }\n  ) => PathRef\n  pathRefs: (editor: Editor) => Set<PathRef>\n  point: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      edge?: 'start' | 'end'\n    }\n  ) => Point\n  pointRef: (\n    editor: Editor,\n    point: Point,\n    options?: {\n      affinity?: 'backward' | 'forward' | null\n    }\n  ) => PointRef\n  pointRefs: (editor: Editor) => Set<PointRef>\n  positions: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<Point, void, undefined>\n  previous: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  range: (editor: Editor, at: Location, to?: Location) => Range\n  rangeRef: (\n    editor: Editor,\n    range: Range,\n    options?: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    }\n  ) => RangeRef\n  rangeRefs: (editor: Editor) => Set<RangeRef>\n  removeMark: (editor: Editor, key: string) => void\n  setNormalizing: (editor: Editor, isNormalizing: boolean) => void\n  start: (editor: Editor, at: Location) => Point\n  string: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      voids?: boolean\n    }\n  ) => string\n  unhangRange: (\n    editor: Editor,\n    range: Range,\n    options?: {\n      voids?: boolean\n    }\n  ) => Range\n  void: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<Element> | undefined\n  withoutNormalizing: (editor: Editor, fn: () => void) => void\n}\n\nconst IS_EDITOR_CACHE = new WeakMap<object, boolean>()\n\nexport const Editor: EditorInterface = {\n  /**\n   * Get the ancestor above a location in the document.\n   */\n\n  above<T extends Ancestor>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    const path = Editor.path(editor, at)\n    const reverse = mode === 'lowest'\n\n    for (const [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse,\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p]\n      }\n    }\n  },\n\n  /**\n   * Add a custom property to the leaf text nodes in the current selection.\n   *\n   * If the selection is currently collapsed, the marks will be added to the\n   * `editor.marks` property instead, and applied when text is inserted next.\n   */\n\n  addMark(editor: Editor, key: string, value: any): void {\n    editor.addMark(key, value)\n  },\n\n  /**\n   * Get the point after a location.\n   */\n\n  after(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.point(editor, at, { edge: 'end' })\n    const focus = Editor.end(editor, [])\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Get the point before a location.\n   */\n\n  before(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.start(editor, [])\n    const focus = Editor.point(editor, at, { edge: 'start' })\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n      reverse: true,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Delete content in the editor backward from the current selection.\n   */\n\n  deleteBackward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteBackward(unit)\n  },\n\n  /**\n   * Delete content in the editor forward from the current selection.\n   */\n\n  deleteForward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteForward(unit)\n  },\n\n  /**\n   * Delete the content in the current selection.\n   */\n\n  deleteFragment(\n    editor: Editor,\n    options: {\n      direction?: 'forward' | 'backward'\n    } = {}\n  ): void {\n    const { direction = 'forward' } = options\n    editor.deleteFragment(direction)\n  },\n\n  /**\n   * Get the start and end points of a location.\n   */\n\n  edges(editor: Editor, at: Location): [Point, Point] {\n    return [Editor.start(editor, at), Editor.end(editor, at)]\n  },\n\n  /**\n   * Get the end point of a location.\n   */\n\n  end(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'end' })\n  },\n\n  /**\n   * Get the first node at a location.\n   */\n\n  first(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'start' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the fragment at a location.\n   */\n\n  fragment(editor: Editor, at: Location): Descendant[] {\n    const range = Editor.range(editor, at)\n    const fragment = Node.fragment(editor, range)\n    return fragment\n  },\n  /**\n   * Check if a node has block children.\n   */\n\n  hasBlocks(editor: Editor, element: Element): boolean {\n    return element.children.some(n => Editor.isBlock(editor, n))\n  },\n\n  /**\n   * Check if a node has inline and text children.\n   */\n\n  hasInlines(editor: Editor, element: Element): boolean {\n    return element.children.some(\n      n => Text.isText(n) || Editor.isInline(editor, n)\n    )\n  },\n\n  /**\n   * Check if a node has text children.\n   */\n\n  hasTexts(editor: Editor, element: Element): boolean {\n    return element.children.every(n => Text.isText(n))\n  },\n\n  /**\n   * Insert a block break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertBreak(editor: Editor): void {\n    editor.insertBreak()\n  },\n\n  /**\n   * Insert a fragment at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertFragment(editor: Editor, fragment: Node[]): void {\n    editor.insertFragment(fragment)\n  },\n\n  /**\n   * Insert a node at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertNode(editor: Editor, node: Node): void {\n    editor.insertNode(node)\n  },\n\n  /**\n   * Insert text at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertText(editor: Editor, text: string): void {\n    editor.insertText(text)\n  },\n\n  /**\n   * Check if a value is a block `Element` object.\n   */\n\n  isBlock(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && !editor.isInline(value)\n  },\n\n  /**\n   * Check if a value is an `Editor` object.\n   */\n\n  isEditor(value: any): value is Editor {\n    if (!isPlainObject(value)) return false\n    const cachedIsEditor = IS_EDITOR_CACHE.get(value)\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor\n    }\n    const isEditor =\n      typeof value.addMark === 'function' &&\n      typeof value.apply === 'function' &&\n      typeof value.deleteBackward === 'function' &&\n      typeof value.deleteForward === 'function' &&\n      typeof value.deleteFragment === 'function' &&\n      typeof value.insertBreak === 'function' &&\n      typeof value.insertFragment === 'function' &&\n      typeof value.insertNode === 'function' &&\n      typeof value.insertText === 'function' &&\n      typeof value.isInline === 'function' &&\n      typeof value.isVoid === 'function' &&\n      typeof value.normalizeNode === 'function' &&\n      typeof value.onChange === 'function' &&\n      typeof value.removeMark === 'function' &&\n      (value.marks === null || isPlainObject(value.marks)) &&\n      (value.selection === null || Range.isRange(value.selection)) &&\n      Node.isNodeList(value.children) &&\n      Operation.isOperationList(value.operations)\n    IS_EDITOR_CACHE.set(value, isEditor)\n    return isEditor\n  },\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n\n  isEnd(editor: Editor, point: Point, at: Location): boolean {\n    const end = Editor.end(editor, at)\n    return Point.equals(point, end)\n  },\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n\n  isEdge(editor: Editor, point: Point, at: Location): boolean {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\n  },\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n\n  isEmpty(editor: Editor, element: Element): boolean {\n    const { children } = element\n    const [first] = children\n    return (\n      children.length === 0 ||\n      (children.length === 1 &&\n        Text.isText(first) &&\n        first.text === '' &&\n        !editor.isVoid(element))\n    )\n  },\n\n  /**\n   * Check if a value is an inline `Element` object.\n   */\n\n  isInline(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isInline(value)\n  },\n\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n\n  isNormalizing(editor: Editor): boolean {\n    const isNormalizing = NORMALIZING.get(editor)\n    return isNormalizing === undefined ? true : isNormalizing\n  },\n\n  /**\n   * Check if a point is the start point of a location.\n   */\n\n  isStart(editor: Editor, point: Point, at: Location): boolean {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false\n    }\n\n    const start = Editor.start(editor, at)\n    return Point.equals(point, start)\n  },\n\n  /**\n   * Check if a value is a void `Element` object.\n   */\n\n  isVoid(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isVoid(value)\n  },\n\n  /**\n   * Get the last node at a location.\n   */\n\n  last(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'end' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the leaf text node at a location.\n   */\n\n  leaf(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Text> {\n    const path = Editor.path(editor, at, options)\n    const node = Node.leaf(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n\n  *levels<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const { at = editor.selection, reverse = false, voids = false } = options\n    let { match } = options\n\n    if (match == null) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    const levels: NodeEntry<T>[] = []\n    const path = Editor.path(editor, at)\n\n    for (const [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue\n      }\n\n      levels.push([n, p])\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break\n      }\n    }\n\n    if (reverse) {\n      levels.reverse()\n    }\n\n    yield* levels\n  },\n\n  /**\n   * Get the marks that would be added to text at the current selection.\n   */\n\n  marks(editor: Editor): Omit<Text, 'text'> | null {\n    const { marks, selection } = editor\n\n    if (!selection) {\n      return null\n    }\n\n    if (marks) {\n      return marks\n    }\n\n    if (Range.isExpanded(selection)) {\n      const [match] = Editor.nodes(editor, { match: Text.isText })\n\n      if (match) {\n        const [node] = match as NodeEntry<Text>\n        const { text, ...rest } = node\n        return rest\n      } else {\n        return {}\n      }\n    }\n\n    const { anchor } = selection\n    const { path } = anchor\n    let [node] = Editor.leaf(editor, path)\n\n    if (anchor.offset === 0) {\n      const prev = Editor.previous(editor, { at: path, match: Text.isText })\n      const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n      })\n\n      if (prev && block) {\n        const [prevNode, prevPath] = prev\n        const [, blockPath] = block\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode as Text\n        }\n      }\n    }\n\n    const { text, ...rest } = node\n    return rest\n  },\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n\n  next<T extends Descendant>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const pointAfterLocation = Editor.after(editor, at, { voids })\n\n    if (!pointAfterLocation) return\n\n    const [, to] = Editor.last(editor, [])\n\n    const span: Span = [pointAfterLocation.path, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the next node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [next] = Editor.nodes(editor, { at: span, match, mode, voids })\n    return next\n  },\n\n  /**\n   * Get the node at a location.\n   */\n\n  node(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry {\n    const path = Editor.path(editor, at, options)\n    const node = Node.get(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n\n  *nodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n    } = options\n    let { match } = options\n\n    if (!match) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    let from\n    let to\n\n    if (Span.isSpan(at)) {\n      from = at[0]\n      to = at[1]\n    } else {\n      const first = Editor.path(editor, at, { edge: 'start' })\n      const last = Editor.path(editor, at, { edge: 'end' })\n      from = reverse ? last : first\n      to = reverse ? first : last\n    }\n\n    const nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: ([n]) => (voids ? false : Editor.isVoid(editor, n)),\n    })\n\n    const matches: NodeEntry<T>[] = []\n    let hit: NodeEntry<T> | undefined\n\n    for (const [node, path] of nodeEntries) {\n      const isLower = hit && Path.compare(path, hit[1]) === 0\n\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue\n      }\n\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return\n        } else {\n          continue\n        }\n      }\n\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path]\n        continue\n      }\n\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      const emit: NodeEntry<T> | undefined =\n        mode === 'lowest' ? hit : [node, path]\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit)\n        } else {\n          yield emit\n        }\n      }\n\n      hit = [node, path]\n    }\n\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit)\n      } else {\n        yield hit\n      }\n    }\n\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches\n    }\n  },\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n\n  normalize(\n    editor: Editor,\n    options: {\n      force?: boolean\n    } = {}\n  ): void {\n    const { force = false } = options\n    const getDirtyPaths = (editor: Editor) => {\n      return DIRTY_PATHS.get(editor) || []\n    }\n\n    if (!Editor.isNormalizing(editor)) {\n      return\n    }\n\n    if (force) {\n      const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\n      DIRTY_PATHS.set(editor, allPaths)\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      /*\n        Fix dirty elements with no children.\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n        Running an initial pass avoids the catch-22 race condition.\n      */\n      for (const dirtyPath of getDirtyPaths(editor)) {\n        if (Node.has(editor, dirtyPath)) {\n          const [node, _] = Editor.node(editor, dirtyPath)\n\n          // Add a text child to elements with no children.\n          // This is safe to do in any order, by definition it can't cause other paths to change.\n          if (Element.isElement(node) && node.children.length === 0) {\n            const child = { text: '' }\n            Transforms.insertNodes(editor, child, {\n              at: dirtyPath.concat(0),\n              voids: true,\n            })\n          }\n        }\n      }\n\n      const max = getDirtyPaths(editor).length * 42 // HACK: better way?\n      let m = 0\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(`\n            Could not completely normalize the editor after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          `)\n        }\n\n        const dirtyPath = getDirtyPaths(editor).pop()!\n\n        // If the node doesn't exist in the tree, it does not need to be normalized.\n        if (Node.has(editor, dirtyPath)) {\n          const entry = Editor.node(editor, dirtyPath)\n          editor.normalizeNode(entry)\n        }\n        m++\n      }\n    })\n  },\n\n  /**\n   * Get the parent node of a location.\n   */\n\n  parent(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Ancestor> {\n    const path = Editor.path(editor, at, options)\n    const parentPath = Path.parent(path)\n    const entry = Editor.node(editor, parentPath)\n    return entry as NodeEntry<Ancestor>\n  },\n\n  /**\n   * Get the path of a location.\n   */\n\n  path(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): Path {\n    const { depth, edge } = options\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        const [, firstPath] = Node.first(editor, at)\n        at = firstPath\n      } else if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        at = lastPath\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at)\n      } else if (edge === 'end') {\n        at = Range.end(at)\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path)\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth)\n    }\n\n    return at\n  },\n\n  hasPath(editor: Editor, path: Path): boolean {\n    return Node.has(editor, path)\n  },\n\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pathRef(\n    editor: Editor,\n    path: Path,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PathRef {\n    const { affinity = 'forward' } = options\n    const ref: PathRef = {\n      current: path,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pathRefs = Editor.pathRefs(editor)\n        pathRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pathRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n\n  pathRefs(editor: Editor): Set<PathRef> {\n    let refs = PATH_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      PATH_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Get the start or end point of a location.\n   */\n\n  point(\n    editor: Editor,\n    at: Location,\n    options: {\n      edge?: 'start' | 'end'\n    } = {}\n  ): Point {\n    const { edge = 'start' } = options\n\n    if (Path.isPath(at)) {\n      let path\n\n      if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        path = lastPath\n      } else {\n        const [, firstPath] = Node.first(editor, at)\n        path = firstPath\n      }\n\n      const node = Node.get(editor, path)\n\n      if (!Text.isText(node)) {\n        throw new Error(\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n        )\n      }\n\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\n    }\n\n    if (Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n      return edge === 'start' ? start : end\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pointRef(\n    editor: Editor,\n    point: Point,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PointRef {\n    const { affinity = 'forward' } = options\n    const ref: PointRef = {\n      current: point,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pointRefs = Editor.pointRefs(editor)\n        pointRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pointRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n\n  pointRefs(editor: Editor): Set<PointRef> {\n    let refs = POINT_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      POINT_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Return all the positions in `at` range where a `Point` can be placed.\n   *\n   * By default, moves forward by individual offsets at a time, but\n   * the `unit` option can be used to to move by character, word, line, or block.\n   *\n   * The `reverse` option can be used to change iteration direction.\n   *\n   * Note: By default void nodes are treated as a single point and iteration\n   * will not happen inside their content unless you pass in true for the\n   * `voids` option, then iteration will occur.\n   */\n\n  *positions(\n    editor: Editor,\n    options: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<Point, void, undefined> {\n    const {\n      at = editor.selection,\n      unit = 'offset',\n      reverse = false,\n      voids = false,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */\n\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    const first = reverse ? end : start\n    let isNewBlock = false\n    let blockText = ''\n    let distance = 0 // Distance for leafText to catch up to blockText.\n    let leafTextRemaining = 0\n    let leafTextOffset = 0\n\n    // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n    for (const [node, path] of Editor.nodes(editor, { at, reverse, voids })) {\n      /*\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n       */\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, so by default we will always\n        // yield their first point. If the `voids` option is set to true,\n        // then we will iterate over their content.\n        if (!voids && editor.isVoid(node)) {\n          yield Editor.start(editor, path)\n          continue\n        }\n\n        // Inline element nodes are ignored as they don't themselves\n        // contribute to `blockText` or `leafText` - their parent and\n        // children do.\n        if (editor.isInline(node)) continue\n\n        // Block element node - set `blockText` to its text content.\n        if (Editor.hasInlines(editor, node)) {\n          // We always exhaust block nodes before encountering a new one:\n          //   console.assert(blockText === '',\n          //     `blockText='${blockText}' - `+\n          //     `not exhausted before new block node`, path)\n\n          // Ensure range considered is capped to `range`, in the\n          // start/end edge cases where block extends beyond range.\n          // Equivalent to this, but presumably more performant:\n          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n          //   blockRange = Range.intersection(range, blockRange) // intersect\n          //   blockText = Editor.string(editor, blockRange, { voids })\n          const e = Path.isAncestor(path, end.path)\n            ? end\n            : Editor.end(editor, path)\n          const s = Path.isAncestor(path, start.path)\n            ? start\n            : Editor.start(editor, path)\n\n          blockText = Editor.string(editor, { anchor: s, focus: e }, { voids })\n          blockText = reverse ? reverseText(blockText) : blockText\n          isNewBlock = true\n        }\n      }\n\n      /*\n       * TEXT LEAF NODE - Iterate through text content, yielding\n       * positions every `distance` offset according to `unit`.\n       */\n      if (Text.isText(node)) {\n        const isFirst = Path.equals(path, first.path)\n\n        // Proof that we always exhaust text nodes before encountering a new one:\n        //   console.assert(leafTextRemaining <= 0,\n        //     `leafTextRemaining=${leafTextRemaining} - `+\n        //     `not exhausted before new leaf text node`, path)\n\n        // Reset `leafText` counters for new text node.\n        if (isFirst) {\n          leafTextRemaining = reverse\n            ? first.offset\n            : node.text.length - first.offset\n          leafTextOffset = first.offset // Works for reverse too.\n        } else {\n          leafTextRemaining = node.text.length\n          leafTextOffset = reverse ? leafTextRemaining : 0\n        }\n\n        // Yield position at the start of node (potentially).\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield { path, offset: leafTextOffset }\n          isNewBlock = false\n        }\n\n        // Yield positions every (dynamically calculated) `distance` offset.\n        while (true) {\n          // If `leafText` has caught up with `blockText` (distance=0),\n          // and if blockText is exhausted, break to get another block node,\n          // otherwise advance blockText forward by the new `distance`.\n          if (distance === 0) {\n            if (blockText === '') break\n            distance = calcDistance(blockText, unit)\n            blockText = blockText.slice(distance)\n          }\n\n          // Advance `leafText` by the current `distance`.\n          leafTextOffset = reverse\n            ? leafTextOffset - distance\n            : leafTextOffset + distance\n          leafTextRemaining = leafTextRemaining - distance\n\n          // If `leafText` is exhausted, break to get a new leaf node\n          // and set distance to the overflow amount, so we'll (maybe)\n          // catch up to blockText in the next leaf text node.\n          if (leafTextRemaining < 0) {\n            distance = -leafTextRemaining\n            break\n          }\n\n          // Successfully walked `distance` offsets through `leafText`\n          // to catch up with `blockText`, so we can reset `distance`\n          // and yield this position in this node.\n          distance = 0\n          yield { path, offset: leafTextOffset }\n        }\n      }\n    }\n    // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n    function calcDistance(text: string, unit: string) {\n      if (unit === 'character') {\n        return getCharacterDistance(text)\n      } else if (unit === 'word') {\n        return getWordDistance(text)\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length\n      }\n      return 1\n    }\n  },\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n\n  previous<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const pointBeforeLocation = Editor.before(editor, at, { voids })\n\n    if (!pointBeforeLocation) {\n      return\n    }\n\n    const [, to] = Editor.first(editor, [])\n\n    // The search location is from the start of the document to the path of\n    // the point before the location passed in\n    const span: Span = [pointBeforeLocation.path, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the previous node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids,\n    })\n\n    return previous\n  },\n\n  /**\n   * Get a range of a location.\n   */\n\n  range(editor: Editor, at: Location, to?: Location): Range {\n    if (Range.isRange(at) && !to) {\n      return at\n    }\n\n    const start = Editor.start(editor, at)\n    const end = Editor.end(editor, to || at)\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  rangeRef(\n    editor: Editor,\n    range: Range,\n    options: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    } = {}\n  ): RangeRef {\n    const { affinity = 'forward' } = options\n    const ref: RangeRef = {\n      current: range,\n      affinity,\n      unref() {\n        const { current } = ref\n        const rangeRefs = Editor.rangeRefs(editor)\n        rangeRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.rangeRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n\n  rangeRefs(editor: Editor): Set<RangeRef> {\n    let refs = RANGE_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      RANGE_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Remove a custom property from all of the leaf text nodes in the current\n   * selection.\n   *\n   * If the selection is currently collapsed, the removal will be stored on\n   * `editor.marks` and applied to the text inserted next.\n   */\n\n  removeMark(editor: Editor, key: string): void {\n    editor.removeMark(key)\n  },\n\n  /**\n   * Manually set if the editor should currently be normalizing.\n   *\n   * Note: Using this incorrectly can leave the editor in an invalid state.\n   *\n   */\n  setNormalizing(editor: Editor, isNormalizing: boolean): void {\n    NORMALIZING.set(editor, isNormalizing)\n  },\n\n  /**\n   * Get the start point of a location.\n   */\n\n  start(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'start' })\n  },\n\n  /**\n   * Get the text string content of a location.\n   *\n   * Note: by default the text of void nodes is considered to be an empty\n   * string, regardless of content, unless you pass in true for the voids option\n   */\n\n  string(\n    editor: Editor,\n    at: Location,\n    options: {\n      voids?: boolean\n    } = {}\n  ): string {\n    const { voids = false } = options\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    let text = ''\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids,\n    })) {\n      let t = node.text\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset)\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset)\n      }\n\n      text += t\n    }\n\n    return text\n  },\n\n  /**\n   * Convert a range into a non-hanging one.\n   */\n\n  unhangRange(\n    editor: Editor,\n    range: Range,\n    options: {\n      voids?: boolean\n    } = {}\n  ): Range {\n    const { voids = false } = options\n    let [start, end] = Range.edges(range)\n\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range\n    }\n\n    const endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n),\n    })\n    const blockPath = endBlock ? endBlock[1] : []\n    const first = Editor.start(editor, [])\n    const before = { anchor: first, focus: end }\n    let skip = true\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids,\n    })) {\n      if (skip) {\n        skip = false\n        continue\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = { path, offset: node.text.length }\n        break\n      }\n    }\n\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Match a void node in the current branch of the editor.\n   */\n\n  void(\n    editor: Editor,\n    options: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<Element> | undefined {\n    return Editor.above(editor, {\n      ...options,\n      match: n => Editor.isVoid(editor, n),\n    })\n  },\n\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n\n  withoutNormalizing(editor: Editor, fn: () => void): void {\n    const value = Editor.isNormalizing(editor)\n    Editor.setNormalizing(editor, false)\n    try {\n      fn()\n    } finally {\n      Editor.setNormalizing(editor, value)\n    }\n    Editor.normalize(editor)\n  },\n}\n\n/**\n * A helper type for narrowing matched nodes with a predicate.\n */\n\nexport type NodeMatch<T extends Node> =\n  | ((node: Node, path: Path) => node is T)\n  | ((node: Node, path: Path) => boolean)\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\nexport type Location = Path | Point | Range\n\nexport interface LocationInterface {\n  isLocation: (value: any) => value is Location\n}\n\nexport const Location: LocationInterface = {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n\n  isLocation(value: any): value is Location {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  },\n}\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\n\nexport type Span = [Path, Path]\n\nexport interface SpanInterface {\n  isSpan: (value: any) => value is Span\n}\n\nexport const Span: SpanInterface = {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n\n  isSpan(value: any): value is Span {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  },\n}\n","import { produce } from 'immer'\nimport { Editor, Path, Range, Text } from '..'\nimport { Element, ElementEntry } from './element'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\nexport type BaseNode = Editor | Element | Text\nexport type Node = Editor | Element | Text\n\nexport interface NodeInterface {\n  ancestor: (root: Node, path: Path) => Ancestor\n  ancestors: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry<Ancestor>, void, undefined>\n  child: (root: Node, index: number) => Descendant\n  children: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry<Descendant>, void, undefined>\n  common: (root: Node, path: Path, another: Path) => NodeEntry\n  descendant: (root: Node, path: Path) => Descendant\n  descendants: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry<Descendant>, void, undefined>\n  elements: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<ElementEntry, void, undefined>\n  extractProps: (node: Node) => NodeProps\n  first: (root: Node, path: Path) => NodeEntry\n  fragment: (root: Node, range: Range) => Descendant[]\n  get: (root: Node, path: Path) => Node\n  has: (root: Node, path: Path) => boolean\n  isNode: (value: any) => value is Node\n  isNodeList: (value: any) => value is Node[]\n  last: (root: Node, path: Path) => NodeEntry\n  leaf: (root: Node, path: Path) => Text\n  levels: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry, void, undefined>\n  matches: (node: Node, props: Partial<Node>) => boolean\n  nodes: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry, void, undefined>\n  parent: (root: Node, path: Path) => Ancestor\n  string: (node: Node) => string\n  texts: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry<Text>, void, undefined>\n}\n\nconst IS_NODE_LIST_CACHE = new WeakMap<any[], boolean>()\n\nexport const Node: NodeInterface = {\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n\n  ancestor(root: Node, path: Path): Ancestor {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  *ancestors(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Ancestor>, void, undefined> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: NodeEntry<Ancestor> = [n, p]\n      yield entry\n    }\n  },\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n\n  child(root: Node, index: number): Descendant {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\n      )\n    }\n\n    const c = root.children[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  },\n\n  /**\n   * Iterate over the children of a node at a specific path.\n   */\n\n  *children(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    const { reverse = false } = options\n    const ancestor = Node.ancestor(root, path)\n    const { children } = ancestor\n    let index = reverse ? children.length - 1 : 0\n\n    while (reverse ? index >= 0 : index < children.length) {\n      const child = Node.child(ancestor, index)\n      const childPath = path.concat(index)\n      yield [child, childPath]\n      index = reverse ? index - 1 : index + 1\n    }\n  },\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n\n  common(root: Node, path: Path, another: Path): NodeEntry {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n\n  descendant(root: Node, path: Path): Descendant {\n    const node = Node.get(root, path)\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the descendant node entries inside a root node.\n   */\n\n  *descendants(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path] as NodeEntry<Descendant>\n      }\n    }\n  },\n\n  /**\n   * Return a generator of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n\n  *elements(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<ElementEntry, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  /**\n   * Extract props from a Node.\n   */\n\n  extractProps(node: Node): NodeProps {\n    if (Element.isAncestor(node)) {\n      const { children, ...properties } = node\n\n      return properties\n    } else {\n      const { text, ...properties } = node\n\n      return properties\n    }\n  },\n\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n\n  first(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        n = n.children[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n\n  fragment(root: Node, range: Range): Descendant[] {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    const newRoot = produce({ children: root.children }, r => {\n      const [start, end] = Range.edges(range)\n      const nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.children.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null\n      }\n    })\n\n    return newRoot.children\n  },\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n\n  get(root: Node, path: Path): Node {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\n            root\n          )}`\n        )\n      }\n\n      node = node.children[p]\n    }\n\n    return node\n  },\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n\n  has(root: Node, path: Path): boolean {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false\n      }\n\n      node = node.children[p]\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n\n  isNode(value: any): value is Node {\n    return (\n      Text.isText(value) || Element.isElement(value) || Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n\n  isNodeList(value: any): value is Node[] {\n    if (!Array.isArray(value)) {\n      return false\n    }\n    const cachedResult = IS_NODE_LIST_CACHE.get(value)\n    if (cachedResult !== undefined) {\n      return cachedResult\n    }\n    const isNodeList = value.every(val => Node.isNode(val))\n    IS_NODE_LIST_CACHE.set(value, isNodeList)\n    return isNodeList\n  },\n\n  /**\n   * Get the last node entry in a root node from a path.\n   */\n\n  last(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        const i = n.children.length - 1\n        n = n.children[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n\n  leaf(root: Node, path: Path): Text {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from lowest to highest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n\n  *levels(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  },\n\n  /**\n   * Check if a node matches a set of props.\n   */\n\n  matches(node: Node, props: Partial<Node>): boolean {\n    return (\n      (Element.isElement(node) &&\n        Element.isElementProps(props) &&\n        Element.matches(node, props)) ||\n      (Text.isText(node) &&\n        Text.isTextProps(props) &&\n        Text.matches(node, props))\n    )\n  },\n\n  /**\n   * Return a generator of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n\n  *nodes(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't descended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.children.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.children.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  },\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n\n  parent(root: Node, path: Path): Ancestor {\n    const parentPath = Path.parent(path)\n    const p = Node.get(root, parentPath)\n\n    if (Text.isText(p)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return p\n  },\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n\n  string(node: Node): string {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.children.map(Node.string).join('')\n    }\n  },\n\n  /**\n   * Return a generator of all leaf text nodes in a root node.\n   */\n\n  *texts(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Text>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\nexport type Ancestor = Editor | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\nexport type NodeEntry<T extends Node = Node> = [T, Path]\n\n/**\n * Convenience type for returning the props of a node.\n */\nexport type NodeProps =\n  | Omit<Editor, 'children'>\n  | Omit<Element, 'children'>\n  | Omit<Text, 'text'>\n","import { ExtendedType, Node, Path, Range } from '..'\nimport isPlainObject from 'is-plain-object'\n\nexport type BaseInsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n}\n\nexport type InsertNodeOperation = ExtendedType<\n  'InsertNodeOperation',\n  BaseInsertNodeOperation\n>\n\nexport type BaseInsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n}\n\nexport type InsertTextOperation = ExtendedType<\n  'InsertTextOperation',\n  BaseInsertTextOperation\n>\n\nexport type BaseMergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n}\n\nexport type MergeNodeOperation = ExtendedType<\n  'MergeNodeOperation',\n  BaseMergeNodeOperation\n>\n\nexport type BaseMoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n}\n\nexport type MoveNodeOperation = ExtendedType<\n  'MoveNodeOperation',\n  BaseMoveNodeOperation\n>\n\nexport type BaseRemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n}\n\nexport type RemoveNodeOperation = ExtendedType<\n  'RemoveNodeOperation',\n  BaseRemoveNodeOperation\n>\n\nexport type BaseRemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n}\n\nexport type RemoveTextOperation = ExtendedType<\n  'RemoveTextOperation',\n  BaseRemoveTextOperation\n>\n\nexport type BaseSetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n}\n\nexport type SetNodeOperation = ExtendedType<\n  'SetNodeOperation',\n  BaseSetNodeOperation\n>\n\nexport type BaseSetSelectionOperation =\n  | {\n      type: 'set_selection'\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      properties: Range\n      newProperties: null\n    }\n\nexport type SetSelectionOperation = ExtendedType<\n  'SetSelectionOperation',\n  BaseSetSelectionOperation\n>\n\nexport type BaseSplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n}\n\nexport type SplitNodeOperation = ExtendedType<\n  'SplitNodeOperation',\n  BaseSplitNodeOperation\n>\n\nexport type NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\nexport type SelectionOperation = SetSelectionOperation\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\nexport type Operation = NodeOperation | SelectionOperation | TextOperation\n\nexport interface OperationInterface {\n  isNodeOperation: (value: any) => value is NodeOperation\n  isOperation: (value: any) => value is Operation\n  isOperationList: (value: any) => value is Operation[]\n  isSelectionOperation: (value: any) => value is SelectionOperation\n  isTextOperation: (value: any) => value is TextOperation\n  inverse: (op: Operation) => Operation\n}\n\nexport const Operation: OperationInterface = {\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n\n  isNodeOperation(value: any): value is NodeOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  },\n\n  /**\n   * Check of a value is an `Operation` object.\n   */\n\n  isOperation(value: any): value is Operation {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'insert_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'merge_node':\n        return (\n          typeof value.position === 'number' &&\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties)\n        )\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'remove_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'set_node':\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      case 'set_selection':\n        return (\n          (value.properties === null && Range.isRange(value.newProperties)) ||\n          (value.newProperties === null && Range.isRange(value.properties)) ||\n          (isPlainObject(value.properties) &&\n            isPlainObject(value.newProperties))\n        )\n      case 'split_node':\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          isPlainObject(value.properties)\n        )\n      default:\n        return false\n    }\n  },\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n\n  isOperationList(value: any): value is Operation[] {\n    return (\n      Array.isArray(value) && value.every(val => Operation.isOperation(val))\n    )\n  },\n\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n\n  isSelectionOperation(value: any): value is SelectionOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  },\n\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n\n  isTextOperation(value: any): value is TextOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  },\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n\n  inverse(op: Operation): Operation {\n    switch (op.type) {\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // If the move happens completely within a single parent the path and\n        // newPath are stable with respect to each other.\n        if (Path.isSibling(path, newPath)) {\n          return { ...op, path: newPath, newPath: path }\n        }\n\n        // If the move does not happen within a single parent it is possible\n        // for the move to impact the true path to the location where the node\n        // was removed from and where it was inserted. We have to adjust for this\n        // and find the original path. We can accomplish this (only in non-sibling)\n        // moves by looking at the impact of the move operation on the node\n        // after the original move path.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_node': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  },\n}\n","import { produce } from 'immer'\nimport { Operation } from '..'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\n\nexport type Path = number[]\n\nexport interface PathInterface {\n  ancestors: (path: Path, options?: { reverse?: boolean }) => Path[]\n  common: (path: Path, another: Path) => Path\n  compare: (path: Path, another: Path) => -1 | 0 | 1\n  endsAfter: (path: Path, another: Path) => boolean\n  endsAt: (path: Path, another: Path) => boolean\n  endsBefore: (path: Path, another: Path) => boolean\n  equals: (path: Path, another: Path) => boolean\n  hasPrevious: (path: Path) => boolean\n  isAfter: (path: Path, another: Path) => boolean\n  isAncestor: (path: Path, another: Path) => boolean\n  isBefore: (path: Path, another: Path) => boolean\n  isChild: (path: Path, another: Path) => boolean\n  isCommon: (path: Path, another: Path) => boolean\n  isDescendant: (path: Path, another: Path) => boolean\n  isParent: (path: Path, another: Path) => boolean\n  isPath: (value: any) => value is Path\n  isSibling: (path: Path, another: Path) => boolean\n  levels: (\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Path[]\n  next: (path: Path) => Path\n  parent: (path: Path) => Path\n  previous: (path: Path) => Path\n  relative: (path: Path, ancestor: Path) => Path\n  transform: (\n    path: Path,\n    operation: Operation,\n    options?: { affinity?: 'forward' | 'backward' | null }\n  ) => Path | null\n}\n\nexport const Path: PathInterface = {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  ancestors(path: Path, options: { reverse?: boolean } = {}): Path[] {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  },\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n\n  common(path: Path, another: Path): Path {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  },\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n\n  compare(path: Path, another: Path): -1 | 0 | 1 {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  },\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n\n  endsAfter(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  },\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n\n  endsAt(path: Path, another: Path): boolean {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  },\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n\n  endsBefore(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  },\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n\n  equals(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  },\n\n  /**\n   * Check if the path of previous sibling node exists\n   */\n\n  hasPrevious(path: Path): boolean {\n    return path[path.length - 1] > 0\n  },\n\n  /**\n   * Check if a path is after another.\n   */\n\n  isAfter(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === 1\n  },\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n\n  isAncestor(path: Path, another: Path): boolean {\n    return path.length < another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is before another.\n   */\n\n  isBefore(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === -1\n  },\n\n  /**\n   * Check if a path is a child of another.\n   */\n\n  isChild(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n\n  isCommon(path: Path, another: Path): boolean {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n\n  isDescendant(path: Path, another: Path): boolean {\n    return path.length > another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is the parent of another.\n   */\n\n  isParent(path: Path, another: Path): boolean {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n\n  isPath(value: any): value is Path {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  },\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n\n  isSibling(path: Path, another: Path): boolean {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  },\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n\n  levels(\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Path[] {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  },\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n\n  next(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  },\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n\n  parent(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  },\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n\n  previous(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  },\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n\n  relative(path: Path, ancestor: Path): Path {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  },\n\n  /**\n   * Transform a path by an operation.\n   */\n\n  transform(\n    path: Path,\n    operation: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Path | null {\n    return produce(path, p => {\n      const { affinity = 'forward' } = options\n\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\n      if (path.length === 0) {\n        return\n      }\n\n      switch (operation.type) {\n        case 'insert_node': {\n          const { path: op } = operation\n\n          if (\n            Path.equals(op, p) ||\n            Path.endsBefore(op, p) ||\n            Path.isAncestor(op, p)\n          ) {\n            p[op.length - 1] += 1\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path: op } = operation\n\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n            return null\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else if (Path.isAncestor(op, p)) {\n            p[op.length - 1] -= 1\n            p[op.length] += position\n          }\n\n          break\n        }\n\n        case 'split_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1\n            } else if (affinity === 'backward') {\n              // Nothing, because it still refers to the right path.\n            } else {\n              return null\n            }\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] += 1\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n            p[op.length - 1] += 1\n            p[op.length] -= position\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path: op, newPath: onp } = operation\n\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(op, onp)) {\n            return\n          }\n\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n            const copy = onp.slice()\n\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\n              copy[op.length - 1] -= 1\n            }\n\n            return copy.concat(p.slice(op.length))\n          } else if (\n            Path.isSibling(op, onp) &&\n            (Path.isAncestor(onp, p) || Path.equals(onp, p))\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            } else {\n              p[op.length - 1] += 1\n            }\n          } else if (\n            Path.endsBefore(onp, p) ||\n            Path.equals(onp, p) ||\n            Path.isAncestor(onp, p)\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            }\n\n            p[onp.length - 1] += 1\n          } else if (Path.endsBefore(op, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1\n            }\n\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n","import { Operation, Path } from '..'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nexport interface PathRef {\n  current: Path | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Path | null\n}\n\nexport interface PathRefInterface {\n  transform: (ref: PathRef, op: Operation) => void\n}\n\nexport const PathRef: PathRefInterface = {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n\n  transform(ref: PathRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport { ExtendedType, Operation, Path } from '..'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\nexport interface BasePoint {\n  path: Path\n  offset: number\n}\n\nexport type Point = ExtendedType<'Point', BasePoint>\n\nexport interface PointInterface {\n  compare: (point: Point, another: Point) => -1 | 0 | 1\n  isAfter: (point: Point, another: Point) => boolean\n  isBefore: (point: Point, another: Point) => boolean\n  equals: (point: Point, another: Point) => boolean\n  isPoint: (value: any) => value is Point\n  transform: (\n    point: Point,\n    op: Operation,\n    options?: { affinity?: 'forward' | 'backward' | null }\n  ) => Point | null\n}\n\nexport const Point: PointInterface = {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n\n  compare(point: Point, another: Point): -1 | 0 | 1 {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  },\n\n  /**\n   * Check if a point is after another.\n   */\n\n  isAfter(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === 1\n  },\n\n  /**\n   * Check if a point is before another.\n   */\n\n  isBefore(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === -1\n  },\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n\n  equals(point: Point, another: Point): boolean {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  },\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n\n  isPoint(value: any): value is Point {\n    return (\n      isPlainObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  },\n\n  /**\n   * Transform a point by an operation.\n   */\n\n  transform(\n    point: Point,\n    op: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Point | null {\n    return produce(point, p => {\n      const { affinity = 'forward' } = options\n      const { path, offset } = p\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node': {\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'insert_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset += op.text.length\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          if (Path.equals(op.path, path)) {\n            p.offset += op.position\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'remove_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset -= Math.min(offset - op.offset, op.text.length)\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'split_node': {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null\n            } else if (\n              op.position < offset ||\n              (op.position === offset && affinity === 'forward')\n            ) {\n              p.offset -= op.position\n\n              p.path = Path.transform(path, op, {\n                ...options,\n                affinity: 'forward',\n              })!\n            }\n          } else {\n            p.path = Path.transform(path, op, options)!\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport type PointEntry = [Point, 'anchor' | 'focus']\n","import { Operation, Point } from '..'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nexport interface PointRef {\n  current: Point | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Point | null\n}\n\nexport interface PointRefInterface {\n  transform: (ref: PointRef, op: Operation) => void\n}\n\nexport const PointRef: PointRefInterface = {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n\n  transform(ref: PointRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    ref.current = point\n\n    if (point == null) {\n      ref.unref()\n    }\n  },\n}\n","import { produce } from 'immer'\nimport isPlainObject from 'is-plain-object'\nimport { ExtendedType, Operation, Path, Point, PointEntry } from '..'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\nexport interface BaseRange {\n  anchor: Point\n  focus: Point\n}\n\nexport type Range = ExtendedType<'Range', BaseRange>\n\nexport interface RangeInterface {\n  edges: (\n    range: Range,\n    options?: {\n      reverse?: boolean\n    }\n  ) => [Point, Point]\n  end: (range: Range) => Point\n  equals: (range: Range, another: Range) => boolean\n  includes: (range: Range, target: Path | Point | Range) => boolean\n  intersection: (range: Range, another: Range) => Range | null\n  isBackward: (range: Range) => boolean\n  isCollapsed: (range: Range) => boolean\n  isExpanded: (range: Range) => boolean\n  isForward: (range: Range) => boolean\n  isRange: (value: any) => value is Range\n  points: (range: Range) => Generator<PointEntry, void, undefined>\n  start: (range: Range) => Point\n  transform: (\n    range: Range,\n    op: Operation,\n    options?: {\n      affinity?: 'forward' | 'backward' | 'outward' | 'inward' | null\n    }\n  ) => Range | null\n}\n\nexport const Range: RangeInterface = {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n\n  edges(\n    range: Range,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): [Point, Point] {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  },\n\n  /**\n   * Get the end point of a range.\n   */\n\n  end(range: Range): Point {\n    const [, end] = Range.edges(range)\n    return end\n  },\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n\n  equals(range: Range, another: Range): boolean {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  },\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n\n  includes(range: Range, target: Path | Point | Range): boolean {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  },\n\n  /**\n   * Get the intersection of a range with another.\n   */\n\n  intersection(range: Range, another: Range): Range | null {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  },\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n\n  isBackward(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  },\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n\n  isCollapsed(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  },\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n\n  isExpanded(range: Range): boolean {\n    return !Range.isCollapsed(range)\n  },\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n\n  isForward(range: Range): boolean {\n    return !Range.isBackward(range)\n  },\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n\n  isRange(value: any): value is Range {\n    return (\n      isPlainObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  },\n\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n\n  *points(range: Range): Generator<PointEntry, void, undefined> {\n    yield [range.anchor, 'anchor']\n    yield [range.focus, 'focus']\n  },\n\n  /**\n   * Get the start point of a range.\n   */\n\n  start(range: Range): Point {\n    const [start] = Range.edges(range)\n    return start\n  },\n\n  /**\n   * Transform a range by an operation.\n   */\n\n  transform(\n    range: Range,\n    op: Operation,\n    options: {\n      affinity?: 'forward' | 'backward' | 'outward' | 'inward' | null\n    } = {}\n  ): Range | null {\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n\n    return produce(range, r => {\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\n\n      if (!anchor || !focus) {\n        return null\n      }\n\n      r.anchor = anchor\n      r.focus = focus\n    })\n  },\n}\n","import { Operation, Range } from '..'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nexport interface RangeRef {\n  current: Range | null\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  unref(): Range | null\n}\n\nexport interface RangeRefInterface {\n  transform: (ref: RangeRef, op: Operation) => void\n}\n\nexport const RangeRef: RangeRefInterface = {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n\n  transform(ref: RangeRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Range.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport isEqual from 'fast-deep-equal'\nimport { Range } from '..'\nimport { ExtendedType } from './custom-types'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\n\nexport interface BaseText {\n  text: string\n}\n\nexport type Text = ExtendedType<'Text', BaseText>\n\nexport interface TextInterface {\n  equals: (text: Text, another: Text, options?: { loose?: boolean }) => boolean\n  isText: (value: any) => value is Text\n  isTextList: (value: any) => value is Text[]\n  isTextProps: (props: any) => props is Partial<Text>\n  matches: (text: Text, props: Partial<Text>) => boolean\n  decorations: (node: Text, decorations: Range[]) => Text[]\n}\n\nexport const Text: TextInterface = {\n  /**\n   * Check if two text nodes are equal.\n   */\n\n  equals(\n    text: Text,\n    another: Text,\n    options: { loose?: boolean } = {}\n  ): boolean {\n    const { loose = false } = options\n\n    function omitText(obj: Record<any, any>) {\n      const { text, ...rest } = obj\n\n      return rest\n    }\n\n    return isEqual(\n      loose ? omitText(text) : text,\n      loose ? omitText(another) : another\n    )\n  },\n\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n\n  isText(value: any): value is Text {\n    return isPlainObject(value) && typeof value.text === 'string'\n  },\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n\n  isTextList(value: any): value is Text[] {\n    return Array.isArray(value) && value.every(val => Text.isText(val))\n  },\n\n  /**\n   * Check if some props are a partial of Text.\n   */\n\n  isTextProps(props: any): props is Partial<Text> {\n    return (props as Partial<Text>).text !== undefined\n  },\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n\n  matches(text: Text, props: Partial<Text>): boolean {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Get the leaves for a text node given decorations.\n   */\n\n  decorations(node: Text, decorations: Range[]): Text[] {\n    let leaves: Text[] = [{ ...node }]\n\n    for (const dec of decorations) {\n      const { anchor, focus, ...rest } = dec\n      const [start, end] = Range.edges(dec)\n      const next = []\n      let o = 0\n\n      for (const leaf of leaves) {\n        const { length } = leaf.text\n        const offset = o\n        o += length\n\n        // If the range encompases the entire leaf, add the range.\n        if (start.offset <= offset && end.offset >= o) {\n          Object.assign(leaf, rest)\n          next.push(leaf)\n          continue\n        }\n\n        // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n        if (\n          (start.offset !== end.offset &&\n            (start.offset === o || end.offset === offset)) ||\n          start.offset > o ||\n          end.offset < offset ||\n          (end.offset === offset && offset !== 0)\n        ) {\n          next.push(leaf)\n          continue\n        }\n\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        let middle = leaf\n        let before\n        let after\n\n        if (end.offset < o) {\n          const off = end.offset - offset\n          after = { ...middle, text: middle.text.slice(off) }\n          middle = { ...middle, text: middle.text.slice(0, off) }\n        }\n\n        if (start.offset > offset) {\n          const off = start.offset - offset\n          before = { ...middle, text: middle.text.slice(0, off) }\n          middle = { ...middle, text: middle.text.slice(off) }\n        }\n\n        Object.assign(middle, rest)\n\n        if (before) {\n          next.push(before)\n        }\n\n        next.push(middle)\n\n        if (after) {\n          next.push(after)\n        }\n      }\n\n      leaves = next\n    }\n\n    return leaves\n  },\n}\n","import { createDraft, finishDraft, isDraft } from 'immer'\nimport {\n  Node,\n  Editor,\n  Selection,\n  Range,\n  Point,\n  Text,\n  Element,\n  Operation,\n  Descendant,\n  NodeEntry,\n  Path,\n  Ancestor,\n} from '..'\n\nexport interface GeneralTransforms {\n  transform: (editor: Editor, op: Operation) => void\n}\n\nconst applyToDraft = (editor: Editor, selection: Selection, op: Operation) => {\n  switch (op.type) {\n    case 'insert_node': {\n      const { path, node } = op\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      if (index > parent.children.length) {\n        throw new Error(\n          `Cannot apply an \"insert_node\" operation at path [${path}] because the destination is past the end of the node.`\n        )\n      }\n\n      parent.children.splice(index, 0, node)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'insert_text': {\n      const { path, offset, text } = op\n      if (text.length === 0) break\n      const node = Node.leaf(editor, path)\n      const before = node.text.slice(0, offset)\n      const after = node.text.slice(offset)\n      node.text = before + text + after\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const node = Node.get(editor, path)\n      const prevPath = Path.previous(path)\n      const prev = Node.get(editor, prevPath)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      if (Text.isText(node) && Text.isText(prev)) {\n        prev.text += node.text\n      } else if (!Text.isText(node) && !Text.isText(prev)) {\n        prev.children.push(...node.children)\n      } else {\n        throw new Error(\n          `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interfaces: ${node} ${prev}`\n        )\n      }\n\n      parent.children.splice(index, 1)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.isAncestor(path, newPath)) {\n        throw new Error(\n          `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n        )\n      }\n\n      const node = Node.get(editor, path)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      // This is tricky, but since the `path` and `newPath` both refer to\n      // the same snapshot in time, there's a mismatch. After either\n      // removing the original position, the second step's path can be out\n      // of date. So instead of using the `op.newPath` directly, we\n      // transform `op.path` to ascertain what the `newPath` would be after\n      // the operation was applied.\n      parent.children.splice(index, 1)\n      const truePath = Path.transform(path, op)!\n      const newParent = Node.get(editor, Path.parent(truePath)) as Ancestor\n      const newIndex = truePath[truePath.length - 1]\n\n      newParent.children.splice(newIndex, 0, node)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const index = path[path.length - 1]\n      const parent = Node.parent(editor, path)\n      parent.children.splice(index, 1)\n\n      // Transform all of the points in the value, but if the point was in the\n      // node that was removed we need to update the range or remove it.\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          const result = Point.transform(point, op)\n\n          if (selection != null && result != null) {\n            selection[key] = result\n          } else {\n            let prev: NodeEntry<Text> | undefined\n            let next: NodeEntry<Text> | undefined\n\n            for (const [n, p] of Node.texts(editor)) {\n              if (Path.compare(p, path) === -1) {\n                prev = [n, p]\n              } else {\n                next = [n, p]\n                break\n              }\n            }\n\n            if (prev) {\n              point.path = prev[1]\n              point.offset = prev[0].text.length\n            } else if (next) {\n              point.path = next[1]\n              point.offset = 0\n            } else {\n              selection = null\n            }\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'remove_text': {\n      const { path, offset, text } = op\n      if (text.length === 0) break\n      const node = Node.leaf(editor, path)\n      const before = node.text.slice(0, offset)\n      const after = node.text.slice(offset + text.length)\n      node.text = before + after\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'set_node': {\n      const { path, properties, newProperties } = op\n\n      if (path.length === 0) {\n        throw new Error(`Cannot set properties on the root node!`)\n      }\n\n      const node = Node.get(editor, path)\n\n      for (const key in newProperties) {\n        if (key === 'children' || key === 'text') {\n          throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n        }\n\n        const value = newProperties[key]\n\n        if (value == null) {\n          delete node[key]\n        } else {\n          node[key] = value\n        }\n      }\n\n      // properties that were previously defined, but are now missing, must be deleted\n      for (const key in properties) {\n        if (!newProperties.hasOwnProperty(key)) {\n          delete node[key]\n        }\n      }\n\n      break\n    }\n\n    case 'set_selection': {\n      const { newProperties } = op\n\n      if (newProperties == null) {\n        selection = newProperties\n      } else {\n        if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = { ...newProperties }\n        }\n\n        for (const key in newProperties) {\n          const value = newProperties[key]\n\n          if (value == null) {\n            if (key === 'anchor' || key === 'focus') {\n              throw new Error(`Cannot remove the \"${key}\" selection property`)\n            }\n\n            delete selection[key]\n          } else {\n            selection[key] = value\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'split_node': {\n      const { path, position, properties } = op\n\n      if (path.length === 0) {\n        throw new Error(\n          `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n        )\n      }\n\n      const node = Node.get(editor, path)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n      let newNode: Descendant\n\n      if (Text.isText(node)) {\n        const before = node.text.slice(0, position)\n        const after = node.text.slice(position)\n        node.text = before\n        newNode = {\n          ...(properties as Partial<Text>),\n          text: after,\n        }\n      } else {\n        const before = node.children.slice(0, position)\n        const after = node.children.slice(position)\n        node.children = before\n\n        newNode = {\n          ...(properties as Partial<Element>),\n          children: after,\n        }\n      }\n\n      parent.children.splice(index + 1, 0, newNode)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n  }\n  return selection\n}\n\nexport const GeneralTransforms: GeneralTransforms = {\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation): void {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    try {\n      selection = applyToDraft(editor, selection, op)\n    } finally {\n      editor.children = finishDraft(editor.children)\n\n      if (selection) {\n        editor.selection = isDraft(selection)\n          ? (finishDraft(selection) as Range)\n          : selection\n      } else {\n        editor.selection = null\n      }\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  Path,\n  Point,\n  Range,\n  Text,\n  Transforms,\n  NodeEntry,\n  Ancestor,\n} from '..'\nimport { NodeMatch } from '../interfaces/editor'\n\nexport interface NodeTransforms {\n  insertNodes: <T extends Node>(\n    editor: Editor,\n    nodes: Node | Node[],\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    }\n  ) => void\n  liftNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => void\n  mergeNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  moveNodes: <T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ) => void\n  removeNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  setNodes: <T extends Node>(\n    editor: Editor,\n    props: Partial<Node>,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  splitNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    }\n  ) => void\n  unsetNodes: <T extends Node>(\n    editor: Editor,\n    props: string | string[],\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  unwrapNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  wrapNodes: <T extends Node>(\n    editor: Editor,\n    element: Element,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n}\n\nexport const NodeTransforms: NodeTransforms = {\n  /**\n   * Insert nodes at a specific location in the Editor.\n   */\n\n  insertNodes<T extends Node>(\n    editor: Editor,\n    nodes: Node | Node[],\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at, match, select } = options\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes]\n      }\n\n      if (nodes.length === 0) {\n        return\n      }\n\n      const [node] = nodes\n\n      // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, [])\n        } else {\n          at = [0]\n        }\n\n        select = true\n      }\n\n      if (select == null) {\n        select = false\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n)\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n)\n          } else {\n            match = n => Editor.isBlock(editor, n)\n          }\n        }\n\n        const [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids,\n        })\n\n        if (entry) {\n          const [, matchPath] = entry\n          const pathRef = Editor.pathRef(editor, matchPath)\n          const isAtEnd = Editor.isEnd(editor, at, matchPath)\n          Transforms.splitNodes(editor, { at, match, mode, voids })\n          const path = pathRef.unref()!\n          at = isAtEnd ? Path.next(path) : path\n        } else {\n          return\n        }\n      }\n\n      const parentPath = Path.parent(at)\n      let index = at[at.length - 1]\n\n      if (!voids && Editor.void(editor, { at: parentPath })) {\n        return\n      }\n\n      for (const node of nodes) {\n        const path = parentPath.concat(index)\n        index++\n        editor.apply({ type: 'insert_node', path, node })\n      }\n\n      if (select) {\n        const point = Editor.end(editor, at)\n\n        if (point) {\n          Transforms.select(editor, point)\n        }\n      }\n    })\n  },\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n\n  liftNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { at = editor.selection, mode = 'lowest', voids = false } = options\n      let { match } = options\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!at) {\n        return\n      }\n\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path.length < 2) {\n          throw new Error(\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n          )\n        }\n\n        const parentNodeEntry = Editor.node(editor, Path.parent(path))\n        const [parent, parentPath] = parentNodeEntry as NodeEntry<Ancestor>\n        const index = path[path.length - 1]\n        const { length } = parent.children\n\n        if (length === 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n          Transforms.removeNodes(editor, { at: parentPath, voids })\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, { at: path, to: parentPath, voids })\n        } else if (index === length - 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        } else {\n          const splitPath = Path.next(path)\n          const toPath = Path.next(parentPath)\n          Transforms.splitNodes(editor, { at: splitPath, voids })\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        }\n      }\n    })\n  },\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n\n  mergeNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const [parent] = Editor.parent(editor, at)\n          match = n => parent.children.includes(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n\n          if (options.at == null) {\n            Transforms.select(editor, at)\n          }\n        }\n      }\n\n      const [current] = Editor.nodes(editor, { at, match, voids, mode })\n      const prev = Editor.previous(editor, { at, match, voids, mode })\n\n      if (!current || !prev) {\n        return\n      }\n\n      const [node, path] = current\n      const [prevNode, prevPath] = prev\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return\n      }\n\n      const newPath = Path.next(prevPath)\n      const commonPath = Path.common(path, prevPath)\n      const isPreviousSibling = Path.isSibling(path, prevPath)\n      const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n\n      // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n      const emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n => levels.includes(n) && hasSingleChildNest(editor, n),\n      })\n\n      const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n      let properties\n      let position\n\n      // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        const { text, ...rest } = node\n        position = prevNode.text.length\n        properties = rest as Partial<Text>\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        const { children, ...rest } = node\n        position = prevNode.children.length\n        properties = rest as Partial<Element>\n      } else {\n        throw new Error(\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n            node\n          )} ${JSON.stringify(prevNode)}`\n        )\n      }\n\n      // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n      }\n\n      // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n      if (emptyRef) {\n        Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n      }\n\n      // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      // if prevNode is first child in parent,don't remove it.\n      if (\n        (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n        (Text.isText(prevNode) &&\n          prevNode.text === '' &&\n          prevPath[prevPath.length - 1] !== 0)\n      ) {\n        Transforms.removeNodes(editor, { at: prevPath, voids })\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties,\n        })\n      }\n\n      if (emptyRef) {\n        emptyRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n\n  moveNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false,\n      } = options\n      let { match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      const toRef = Editor.pathRef(editor, to)\n      const targets = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const newPath = toRef.current!\n\n        if (path.length !== 0) {\n          editor.apply({ type: 'move_node', path, newPath })\n        }\n\n        if (\n          toRef.current &&\n          Path.isSibling(newPath, path) &&\n          Path.isAfter(newPath, path)\n        ) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current)\n        }\n      }\n\n      toRef.unref()\n    })\n  },\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n\n  removeNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      const depths = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path) {\n          const [node] = Editor.node(editor, path)\n          editor.apply({ type: 'remove_node', path, node })\n        }\n      }\n    })\n  },\n\n  /**\n   * Set new properties on the nodes at a location.\n   */\n\n  setNodes<T extends Node>(\n    editor: Editor,\n    props: Partial<Node>,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (split && Range.isRange(at)) {\n        const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\n        const [start, end] = Range.edges(at)\n        const splitMode = mode === 'lowest' ? 'lowest' : 'highest'\n        const endAtEndOfNode = Editor.isEnd(editor, end, end.path)\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n          always: !endAtEndOfNode,\n        })\n        const startAtStartOfNode = Editor.isStart(editor, start, start.path)\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n          always: !startAtStartOfNode,\n        })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      for (const [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids,\n      })) {\n        const properties: Partial<Node> = {}\n        const newProperties: Partial<Node> = {}\n\n        // You can't set properties on the editor node.\n        if (path.length === 0) {\n          continue\n        }\n\n        for (const k in props) {\n          if (k === 'children' || k === 'text') {\n            continue\n          }\n\n          if (props[k] !== node[k]) {\n            // Omit new properties from the old property list rather than set them to undefined\n            if (node.hasOwnProperty(k)) properties[k] = node[k]\n            newProperties[k] = props[k]\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties,\n          })\n        }\n      }\n    })\n  },\n\n  /**\n   * Split the nodes at a specific location.\n   */\n\n  splitNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', voids = false } = options\n      let { match, at = editor.selection, height = 0, always = false } = options\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n)\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at)\n      }\n\n      // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n      if (Path.isPath(at)) {\n        const path = at\n        const point = Editor.point(editor, path)\n        const [parent] = Editor.parent(editor, path)\n        match = n => n === parent\n        height = point.path.length - path.length + 1\n        at = point\n        always = true\n      }\n\n      if (!at) {\n        return\n      }\n\n      const beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward',\n      })\n      const [highest] = Editor.nodes(editor, { at, match, mode, voids })\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = Editor.void(editor, { at, mode: 'highest' })\n      const nudge = 0\n\n      if (!voids && voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          let after = Editor.after(editor, voidPath)\n\n          if (!after) {\n            const text = { text: '' }\n            const afterPath = Path.next(voidPath)\n            Transforms.insertNodes(editor, text, { at: afterPath, voids })\n            after = Editor.point(editor, afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      const afterRef = Editor.pointRef(editor, at)\n      const depth = at.path.length - height\n      const [, highestPath] = highest\n      const lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n\n      for (const [node, path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (!voids && Editor.isVoid(editor, node))\n        ) {\n          break\n        }\n\n        const point = beforeRef.current!\n        const isEnd = Editor.isEnd(editor, point, path)\n\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\n          split = true\n          const properties = Node.extractProps(node)\n          editor.apply({\n            type: 'split_node',\n            path,\n            position,\n            properties,\n          })\n        }\n\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || Editor.end(editor, [])\n        Transforms.select(editor, point)\n      }\n\n      beforeRef.unref()\n      afterRef.unref()\n    })\n  },\n\n  /**\n   * Unset properties on the nodes at a location.\n   */\n\n  unsetNodes<T extends Node>(\n    editor: Editor,\n    props: string | string[],\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    if (!Array.isArray(props)) {\n      props = [props]\n    }\n\n    const obj = {}\n\n    for (const key of props) {\n      obj[key] = null\n    }\n\n    Transforms.setNodes(editor, obj, options)\n  },\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n\n  unwrapNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      const rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const [node] = Editor.node(editor, path)\n        let range = Editor.range(editor, path)\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current!, range)!\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => Element.isAncestor(node) && node.children.includes(n),\n          voids,\n        })\n      }\n\n      if (rangeRef) {\n        rangeRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n\n  wrapNodes<T extends Node>(\n    editor: Editor,\n    element: Element,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { match, at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at)\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        const [start, end] = Range.edges(at)\n        const rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward',\n        })\n        Transforms.splitNodes(editor, { at: end, match, voids })\n        Transforms.splitNodes(editor, { at: start, match, voids })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      const roots = Array.from(\n        Editor.nodes(editor, {\n          at,\n          match: editor.isInline(element)\n            ? n => Editor.isBlock(editor, n)\n            : n => Editor.isEditor(n),\n          mode: 'lowest',\n          voids,\n        })\n      )\n\n      for (const [, rootPath] of roots) {\n        const a = Range.isRange(at)\n          ? Range.intersection(at, Editor.range(editor, rootPath))\n          : at\n\n        if (!a) {\n          continue\n        }\n\n        const matches = Array.from(\n          Editor.nodes(editor, { at: a, match, mode, voids })\n        )\n\n        if (matches.length > 0) {\n          const [first] = matches\n          const last = matches[matches.length - 1]\n          const [, firstPath] = first\n          const [, lastPath] = last\n\n          if (firstPath.length === 0 && lastPath.length === 0) {\n            // if there's no matching parent - usually means the node is an editor - don't do anything\n            continue\n          }\n\n          const commonPath = Path.equals(firstPath, lastPath)\n            ? Path.parent(firstPath)\n            : Path.common(firstPath, lastPath)\n\n          const range = Editor.range(editor, firstPath, lastPath)\n          const commonNodeEntry = Editor.node(editor, commonPath)\n          const [commonNode] = commonNodeEntry\n          const depth = commonPath.length + 1\n          const wrapperPath = Path.next(lastPath.slice(0, depth))\n          const wrapper = { ...element, children: [] }\n          Transforms.insertNodes(editor, wrapper, { at: wrapperPath, voids })\n\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n =>\n              Element.isAncestor(commonNode) && commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids,\n          })\n        }\n      }\n    })\n  },\n}\n\nconst hasSingleChildNest = (editor: Editor, node: Node): boolean => {\n  if (Element.isElement(node)) {\n    const element = node as Element\n    if (Editor.isVoid(editor, node)) {\n      return true\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0])\n    } else {\n      return false\n    }\n  } else if (Editor.isEditor(node)) {\n    return false\n  } else {\n    return true\n  }\n}\n\n/**\n * Convert a range into a point by deleting it's content.\n */\n\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = Editor.pointRef(editor, end)\n    Transforms.delete(editor, { at: range })\n    return pointRef.unref()\n  }\n}\n\nconst matchPath = (editor: Editor, path: Path): ((node: Node) => boolean) => {\n  const [node] = Editor.node(editor, path)\n  return n => n === node\n}\n","import { Editor, Location, Point, Range, Transforms } from '..'\n\nexport interface SelectionTransforms {\n  collapse: (\n    editor: Editor,\n    options?: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  deselect: (editor: Editor) => void\n  move: (\n    editor: Editor,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  select: (editor: Editor, target: Location) => void\n  setPoint: (\n    editor: Editor,\n    props: Partial<Point>,\n    options?: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  setSelection: (editor: Editor, props: Partial<Range>) => void\n}\n\nexport const SelectionTransforms: SelectionTransforms = {\n  /**\n   * Collapse the selection.\n   */\n\n  collapse(\n    editor: Editor,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { edge = 'anchor' } = options\n    const { selection } = editor\n\n    if (!selection) {\n      return\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor)\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus)\n    } else if (edge === 'start') {\n      const [start] = Range.edges(selection)\n      Transforms.select(editor, start)\n    } else if (edge === 'end') {\n      const [, end] = Range.edges(selection)\n      Transforms.select(editor, end)\n    }\n  },\n\n  /**\n   * Unset the selection.\n   */\n\n  deselect(editor: Editor): void {\n    const { selection } = editor\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null,\n      })\n    }\n  },\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n\n  move(\n    editor: Editor,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { selection } = editor\n    const { distance = 1, unit = 'character', reverse = false } = options\n    let { edge = null } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const opts = { distance, unit }\n    const props: Partial<Range> = {}\n\n    if (edge == null || edge === 'anchor') {\n      const point = reverse\n        ? Editor.before(editor, anchor, opts)\n        : Editor.after(editor, anchor, opts)\n\n      if (point) {\n        props.anchor = point\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      const point = reverse\n        ? Editor.before(editor, focus, opts)\n        : Editor.after(editor, focus, opts)\n\n      if (point) {\n        props.focus = point\n      }\n    }\n\n    Transforms.setSelection(editor, props)\n  },\n\n  /**\n   * Set the selection to a new value.\n   */\n\n  select(editor: Editor, target: Location): void {\n    const { selection } = editor\n    target = Editor.range(editor, target)\n\n    if (selection) {\n      Transforms.setSelection(editor, target)\n      return\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\n          target\n        )}`\n      )\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target,\n    })\n  },\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n\n  setPoint(\n    editor: Editor,\n    props: Partial<Point>,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { selection } = editor\n    let { edge = 'both' } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const point = edge === 'anchor' ? anchor : focus\n\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: { ...point, ...props },\n    })\n  },\n\n  /**\n   * Set new properties on the selection.\n   */\n\n  setSelection(editor: Editor, props: Partial<Range>): void {\n    const { selection } = editor\n    const oldProps: Partial<Range> | null = {}\n    const newProps: Partial<Range> = {}\n\n    if (!selection) {\n      return\n    }\n\n    for (const k in props) {\n      if (\n        (k === 'anchor' &&\n          props.anchor != null &&\n          !Point.equals(props.anchor, selection.anchor)) ||\n        (k === 'focus' &&\n          props.focus != null &&\n          !Point.equals(props.focus, selection.focus)) ||\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\n      ) {\n        oldProps[k] = selection[k]\n        newProps[k] = props[k]\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps,\n      })\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Path,\n  Text,\n  Point,\n  Range,\n  Transforms,\n} from '..'\n\nexport interface TextTransforms {\n  delete: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  insertFragment: (\n    editor: Editor,\n    fragment: Node[],\n    options?: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  insertText: (\n    editor: Editor,\n    text: string,\n    options?: {\n      at?: Location\n      voids?: boolean\n    }\n  ) => void\n}\n\nexport const TextTransforms: TextTransforms = {\n  /**\n   * Delete content in the editor.\n   */\n\n  delete(\n    editor: Editor,\n    options: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false,\n      } = options\n      let { at = editor.selection, hanging = false } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Point.isPoint(at)) {\n        const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n        if (!voids && furthestVoid) {\n          const [, voidPath] = furthestVoid\n          at = voidPath\n        } else {\n          const opts = { unit, distance }\n          const target = reverse\n            ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n            : Editor.after(editor, at, opts) || Editor.end(editor, [])\n          at = { anchor: at, focus: target }\n          hanging = true\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, { at, voids })\n        return\n      }\n\n      if (Range.isCollapsed(at)) {\n        return\n      }\n\n      if (!hanging) {\n        const [, end] = Range.edges(at)\n        const endOfDoc = Editor.end(editor, [])\n\n        if (!Point.equals(end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, { voids })\n        }\n      }\n\n      let [start, end] = Range.edges(at)\n      const startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids,\n      })\n      const endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids,\n      })\n      const isAcrossBlocks =\n        startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n      const isSingleText = Path.equals(start.path, end.path)\n      const startVoid = voids\n        ? null\n        : Editor.void(editor, { at: start, mode: 'highest' })\n      const endVoid = voids\n        ? null\n        : Editor.void(editor, { at: end, mode: 'highest' })\n\n      // If the start or end points are inside an inline void, nudge them out.\n      if (startVoid) {\n        const before = Editor.before(editor, start)\n\n        if (\n          before &&\n          startBlock &&\n          Path.isAncestor(startBlock[1], before.path)\n        ) {\n          start = before\n        }\n      }\n\n      if (endVoid) {\n        const after = Editor.after(editor, end)\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after\n        }\n      }\n\n      // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n      const matches: NodeEntry[] = []\n      let lastPath: Path | undefined\n\n      for (const entry of Editor.nodes(editor, { at, voids })) {\n        const [node, path] = entry\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue\n        }\n\n        if (\n          (!voids && Editor.isVoid(editor, node)) ||\n          (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n        ) {\n          matches.push(entry)\n          lastPath = path\n        }\n      }\n\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n      const startRef = Editor.pointRef(editor, start)\n      const endRef = Editor.pointRef(editor, end)\n\n      if (!isSingleText && !startVoid) {\n        const point = startRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const { offset } = start\n        const text = node.text.slice(offset)\n        if (text.length > 0)\n          editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        Transforms.removeNodes(editor, { at: path, voids })\n      }\n\n      if (!endVoid) {\n        const point = endRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const offset = isSingleText ? start.offset : 0\n        const text = node.text.slice(offset, end.offset)\n        if (text.length > 0)\n          editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      if (\n        !isSingleText &&\n        isAcrossBlocks &&\n        endRef.current &&\n        startRef.current\n      ) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids,\n        })\n      }\n\n      const point = reverse\n        ? startRef.unref() || endRef.unref()\n        : endRef.unref() || startRef.unref()\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point)\n      }\n    })\n  },\n\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n\n  insertFragment(\n    editor: Editor,\n    fragment: Node[],\n    options: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!fragment.length) {\n        return\n      }\n\n      if (!at) {\n        return\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at)\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n      const inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (inlineElementMatch) {\n        const [, inlinePath] = inlineElementMatch\n\n        if (Editor.isEnd(editor, at, inlinePath)) {\n          const after = Editor.after(editor, inlinePath)!\n          at = after\n        } else if (Editor.isStart(editor, at, inlinePath)) {\n          const before = Editor.before(editor, inlinePath)!\n          at = before\n        }\n      }\n\n      const blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids,\n      })!\n      const [, blockPath] = blockMatch\n      const isBlockStart = Editor.isStart(editor, at, blockPath)\n      const isBlockEnd = Editor.isEnd(editor, at, blockPath)\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\n      const mergeEnd = !isBlockEnd\n      const [, firstPath] = Node.first({ children: fragment }, [])\n      const [, lastPath] = Node.last({ children: fragment }, [])\n\n      const matches: NodeEntry[] = []\n      const matcher = ([n, p]: NodeEntry) => {\n        if (\n          mergeStart &&\n          Path.isAncestor(p, firstPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        if (\n          mergeEnd &&\n          Path.isAncestor(p, lastPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        return true\n      }\n\n      for (const entry of Node.nodes(\n        { children: fragment },\n        { pass: matcher }\n      )) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry)\n        }\n      }\n\n      const starts = []\n      const middles = []\n      const ends = []\n      let starting = true\n      let hasBlocks = false\n\n      for (const [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false\n          hasBlocks = true\n          middles.push(node)\n        } else if (starting) {\n          starts.push(node)\n        } else {\n          ends.push(node)\n        }\n      }\n\n      const [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })!\n\n      const [, inlinePath] = inlineMatch\n      const isInlineStart = Editor.isStart(editor, at, inlinePath)\n      const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\n\n      const middleRef = Editor.pathRef(\n        editor,\n        isBlockEnd ? Path.next(blockPath) : blockPath\n      )\n\n      const endRef = Editor.pathRef(\n        editor,\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\n      )\n\n      Transforms.splitNodes(editor, {\n        at,\n        match: n =>\n          hasBlocks\n            ? Editor.isBlock(editor, n)\n            : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids,\n      })\n\n      const startRef = Editor.pathRef(\n        editor,\n        !isInlineStart || (isInlineStart && isInlineEnd)\n          ? Path.next(inlinePath)\n          : inlinePath\n      )\n\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current!,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (!options.at) {\n        let path\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current!)\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current!)\n        } else {\n          path = Path.previous(startRef.current!)\n        }\n\n        const end = Editor.end(editor, path)\n        Transforms.select(editor, end)\n      }\n\n      startRef.unref()\n      middleRef.unref()\n      endRef.unref()\n    })\n  },\n\n  /**\n   * Insert a string of text in the Editor.\n   */\n\n  insertText(\n    editor: Editor,\n    text: string,\n    options: {\n      at?: Location\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const end = Range.end(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at, voids })\n          at = pointRef.unref()!\n          Transforms.setSelection(editor, { anchor: at, focus: at })\n        }\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      const { path, offset } = at\n      if (text.length > 0)\n        editor.apply({ type: 'insert_text', path, offset, text })\n    })\n  },\n}\n","import { GeneralTransforms } from './general'\nimport { NodeTransforms } from './node'\nimport { SelectionTransforms } from './selection'\nimport { TextTransforms } from './text'\n\nexport const Transforms: GeneralTransforms &\n  NodeTransforms &\n  SelectionTransforms &\n  TextTransforms = {\n  ...GeneralTransforms,\n  ...NodeTransforms,\n  ...SelectionTransforms,\n  ...TextTransforms,\n}\n"],"names":["DIRTY_PATHS","WeakMap","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","createEditor","editor","children","operations","selection","marks","isInline","isVoid","onChange","apply","op","Editor","pathRefs","ref","PathRef","transform","pointRefs","PointRef","rangeRefs","RangeRef","set","Set","dirtyPaths","add","path","key","join","has","push","oldDirtyPaths","get","newDirtyPaths","getDirtyPaths","newPath","Path","Transforms","normalize","type","Promise","resolve","then","addMark","value","Range","isExpanded","setNodes","match","Text","isText","split","deleteBackward","unit","isCollapsed","reverse","deleteForward","deleteFragment","direction","getFragment","Node","fragment","insertBreak","splitNodes","always","insertFragment","insertNode","node","insertNodes","insertText","text","inline","above","n","mode","inlinePath","isEnd","anchor","point","after","setSelection","focus","normalizeNode","entry","Element","isElement","length","child","at","concat","voids","shouldHaveInlines","isEditor","i","currentNode","prev","isLast","isInlineOrText","removeNodes","newChild","equals","loose","mergeNodes","removeMark","unsetNodes","levels","descendants","Array","from","nodes","p","ancestors","previousPath","previous","oldAncestors","newAncestors","ancestor","newParent","newIndex","resultPath","nextPath","next","SPACE","PUNCTUATION","CHAMELEON","SURROGATE_START","SURROGATE_END","ZERO_WIDTH_JOINER","getCharacterDistance","offset","charCode","charCodeAt","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","started","char","charAt","l","slice","rest","isWordCharacter","remaining","test","code","isPlainObject","isNodeList","isAncestor","isElementList","isArray","every","val","isElementProps","props","undefined","isElementType","elementVal","elementKey","matches","element","IS_EDITOR_CACHE","options","edge","end","range","distance","d","target","positions","before","start","edges","first","hasBlocks","some","isBlock","hasInlines","hasTexts","cachedIsEditor","isRange","Operation","isOperationList","Point","isEdge","isStart","isEmpty","isNormalizing","last","leaf","block","prevNode","prevPath","blockPath","pointAfterLocation","to","span","isPath","Error","parent","includes","universal","Span","isSpan","nodeEntries","pass","hit","isLower","compare","emit","force","allPaths","withoutNormalizing","dirtyPath","_","max","m","pop","parentPath","depth","firstPath","lastPath","common","isPoint","hasPath","pathRef","affinity","current","unref","refs","pointRef","isNewBlock","blockText","leafTextRemaining","leafTextOffset","e","s","string","reverseText","isFirst","calcDistance","pointBeforeLocation","rangeRef","setNormalizing","t","unhangRange","endBlock","skip","isBefore","fn","Location","isLocation","IS_NODE_LIST_CACHE","root","index","JSON","stringify","c","childPath","another","descendant","elements","extractProps","properties","newRoot","produce","r","splice","isNode","cachedResult","isTextProps","visited","isAfter","nextIndex","map","texts","isNodeOperation","isOperation","endsWith","position","newProperties","isSelectionOperation","isTextOperation","inverse","isSibling","inversePath","inverseNewPath","paths","av","bv","min","Math","endsAfter","as","bs","endsAt","endsBefore","hasPrevious","isChild","isCommon","isDescendant","isParent","al","bl","list","relative","operation","onp","copy","result","isBackward","rs","re","ts","te","isAfterStart","isBeforeEnd","intersection","s1","e1","s2","e2","isForward","points","affinityAnchor","affinityFocus","omitText","obj","isEqual","isTextList","hasOwnProperty","decorations","leaves","dec","o","Object","assign","middle","off","applyToDraft","truePath","newNode","GeneralTransforms","createDraft","finishDraft","isDraft","NodeTransforms","hanging","select","matchPath","isAtEnd","liftNodes","parentNodeEntry","toPath","moveNodes","splitPath","commonPath","isPreviousSibling","emptyAncestor","hasSingleChildNest","emptyRef","toRef","targets","depths","splitMode","endAtEndOfNode","startAtStartOfNode","k","keys","height","deleteRange","beforeRef","highest","voidMatch","nudge","voidNode","voidPath","afterPath","siblingHeight","afterRef","highestPath","lowestPath","unwrapNodes","wrapNodes","roots","rootPath","a","commonNodeEntry","commonNode","wrapperPath","wrapper","SelectionTransforms","collapse","deselect","move","opts","setPoint","oldProps","newProps","TextTransforms","furthestVoid","endOfDoc","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","startRef","endRef","inlineElementMatch","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","starts","middles","ends","starting","inlineMatch","isInlineStart","isInlineEnd","middleRef"],"mappings":"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"}